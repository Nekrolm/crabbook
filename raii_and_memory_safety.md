# RAII и безопасность памяти

При системной разработке на Rust довольно часто можно столкнуться с необходимостью оборачивать вызовы к C библиотеками. Это совершенно нормально: Rust довольно молодой язык, а огромное число проверенных временем библиотек написаны на C или C++. И при решении задач бизнеса не разумно просто так брать и отказываться от готовых решений: зачем конкретно вам тратить месяцы и годы на переизобретение колес, если вам нужно лишь доехать?  
Так  что `unsafe {}` нам дан в том числе чтоб иметь возможность доехать. Т.е. вызывать внешние небезопасные C функции.

Почти все библиотеки на C предоставляют методы создания и удаления каких-то своих внутренних объектов.
И Rust, как C++ [^1], предлагает использовать деструкторы (и идиому RAII), чтоб не забывать удалять эти объекты.

В Rust деструкторы определяются через реализацию типажа `Drop`

```rust
struct MyCHandle(NonNull<c_lib_handle_t>);

impl Drop for MyCHandle {
    fn drop(&mut self) {
        unsafe {
            destroy_c_handle(self.0.as_ptr())
        }
    }
}
```
Всё просто и понятно.

Разработчики, пришедшие в Rust из C++, при оборачивании всяких небезопасных внешних вызовов к C библиотекам в структуры с деструкторами частенько могут столкнуться с одной весьма нетривиальной и неочевидной проблемой:

Да, деструкторы уберегают нас от утечек ресурсов. Ими можно обеспечить выполнение кода, несмотря на досрочный выход из функции, можно огранизовать ими откат транзакций в случае исключений/паник/если явно не транзакция не подтверждена. Много чего можно. 
И если мы правильно правильно определили кто владеет тем или иным объектом, у нас и double free не произойдет.

Давайте рассмотрим пример:

Пусть С блиотека предоставляет следующие две функции

```C
typedef void (*c_callback_t)(const uint8_t*, size_t, void* ctx)
void start_handle_data(c_lib_handle_t* handle, c_callback_t cbk, void* ctx);

void stop_handle_data(c_lib_handle_t* handle);
```

Они запускают и останавливают **асинхронный** прием данных

При оборачивании в безопасный Rust разработчик разумно объявил для них RAII структуру:

```rust
use std::marker::PhantomData;
use std::ffi::c_void;

struct AsyncHandleGuard<'a, F> {
    // Берем уникальную ссылку на MyCHandle
    // потому что только один обработчик может
    // быть установлен и использоватсья в моменте
    handle: &'a mut MyCHandle,
    // Возьмем ссылку на F, потому как в C 
    // мы не отдаем библиотеке владение коллбэком
    // В деструкторе мы вызовем stop,
    // так что ссылка может быть валидна столько же
    // сколько и ссылка MyCHandle
    // 
    // Нам также не нужно хранить ссылку здесь, 
    // а лишь пометку, что ссылка захвачена и захвачен
    // ее lifetime:
    // мы отдаем ссылку в C библиотеку. 
    // Там она и будет сохранена.
    // Также, без хранения ссылки здесь,
    // мы избежим потенциального сосуществования двух
    // &mut ссылок единовременно: одной в этом потоке
    // другой в потоке C-библиотеки, при вызове коллбека
    _callback_lifetime: PhantomData<&'a mut F>,
}

impl <F> Drop for AsyncHandleGuard<'_, F> {

    fn drop(&mut self) {
        unsafe { stop_handle_data(self.handle.0.as_ptr()) }
    }

}

// Несмотря на потенциальную передачу ссылки в
// другой поток, 
// + Sync не нужен:
// Ссылка уникальная и доступ будет уникальный по гарантиям библиотеки
// Нужен только + Send, чтоб &mut F был Send

impl<'a, F: FnMut(&[u8]) + Send> AsyncHandleGuard<'a, F> {

    fn new(h: &'a mut MyCHandle, f: &'a mut F) -> Self {
        unsafe {
            start_handle_data(
                h.0.as_ptr(), Some(Self::handle),
                (f as *mut F).cast::<c_void>(),
            );
        }
        Self {
            handle: h,
            _callback_lifetime: PhantomData,
        }
    }

    unsafe extern "C" fn handle(data: *const u8, len: usize, ctx: *mut c_void) {
        // гарантировано библиотекой: мы передали указатель
        // *mut F -- на же его и вернули
        let f = unsafe { &mut *(ctx.cast::<F>()) };
        // гарантировано библиотекой: 
        // не null, инициализированный
        // и валидный диапазон
        let data = unsafe { std::slice::from_raw_parts(data, len) };
    }
}


impl MyCHandle {
    pub fn start<'a, F: FnMut(&[u8])>(&'a mut self, callback: &'a mut F) -> AsyncHandleGuard<'a, F> {
        AsyncHandleGuard::new(
            self, callback
        )
    }
}

```

И вроде как даже все работает ожидаемым образом

```rust
fn try_start(handle: &mut MyCHandle) {

    let mut buffer = Vec::<u8>::new();
    
    let mut callback = |data: &[u8]| { buffer.extend_from_slice(data); };
    
    // Ok
    let guard = handle.start(&mut callback);
    
    // Ошибка компиляции -- уже используются
    let guard = handle.start(&mut callback);
    // Ошибка компиляции -- уже используются.
    // и коллбек не доживет
    let guard = handle.start(&mut |data| {println!("data");});
}       
```

Но вся хитрость и сложность **корректной** (sound) реализации публичных безопасных интерфейсов в Rust в том, что нельзя допускать возможности порчи памяти ни при каких, даже самых безумных комбинациях любых вызовов безопасных функций. Не только вашей библиотеки, а какой-либо библиотеки, в том числе и стандартной.

В предыдущей [части](crafting_reference_to_owned.md), мы видели, что вызовы деструкторов можно подавить. И Методы, отключающие исполнение из исполнение: `std::mem::forget`, `std::mem::ManuallyDrop` -- не требуют `unsafe {}`! [^3]. 

А это значит, что при обеспечении безопасности памяти в публичных библиотеках, в и их публичных API **нельзя** [^2]
предполагать, что деструкторы будут вызваны.

```rust
fn try_start(handle: &mut MyCHandle) {
    let mut buffer = Vec::<u8>::new();
    
    let mut callback = |data: &[u8]| { buffer.extend_from_slice(data); };
    
    // Ok
    let guard = handle.start(&mut callback);
    std::mem::forget(guard);
    // Компилируется, но теперь, после выхода из try_start
    // внутри С библиотеки 
    // останется висячая ссылка на локальную переменную
    // и мы получим порчу памяти, когда библиотека
    // вызовет обработчик
}
```

Эта тонкость оставила отпечаток на многих API

1. `std::thread::spawn` -- новый поток не может захватывать non-static ссылки

```rust
// Владение F передается в новый поток
pub fn spawn<F, T>(f: F) -> JoinHandle<T> where
    // F и T не должны захватывать никаких короткоживущих ссылок
    // Иначе, даже если бы деструктор JainHandle всегда дожидался завершения потока, его можно было бы отключить
    // и оставить поток с висячей ссылкой 
    F: FnOnce() -> T + Send + 'static,
    T: Send + 'static,
```

2. `std::thread::scope` -- API, которое позволяется стартовать потоки, захватывающие ссылки на локальные объекты.
Если мы на него посмотрим, то заметим, что оно довольно нетривиальное:

```rust
// Чтоб не было возможности отключить деструкторы
// scope не возращает никаких ScopeHandle<'a>, ожидающих завершения потоков. Ожиданием занимается сама функция.
pub fn scope<'env, F, T>(f: F) -> T
where
    // Объект Scope, создающий потоки, передается 
    // в принимающую функцию-продолжение
    // Передается по ссылке, чтоб также нельзя было 
    // отключить его деструктор
    F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T,
```

```rust
// Методы spawn возвращают ScopedJoindHandle,
// Но эти объекты предоставляют лишь возможность подождать
// завершения конкретного потока (чтоб получить результат).
// Они ничего не ждут в своих деструкторах. 
pub fn spawn<F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>
where
    F: FnOnce() -> T + Send + 'scope,
    T: Send + 'scope,
```

```rust
// И если мы заглянем еще глубже:
// https://doc.rust-lang.org/src/std/thread/mod.rs.html#1800


struct JoinInner<'scope, T> {
    native: imp::Thread,
    thread: Thread,
    // Увидим, что здесь дополнительно аллоцирован буфер
    // для получения результата, так что 
    // если кто-то сделает std::mem::forget(scoped_join_handle), произойдет утечка памяти и...
    packet: Arc<Packet<'scope, T>>,
}
```

```rust

// https://doc.rust-lang.org/src/std/thread/mod.rs.html#1794

impl<'scope, T> Drop for Packet<'scope, T> {
    fn drop(&mut self) {
        let unhandled_panic = matches!(self.result.get_mut(), Some(Err(_)));
        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| {
            *self.result.get_mut() = None;
        })) {
            rtabort!("thread result panicked on drop");
        }
        if let Some(scope) = &self.scope {
            // ! ... и scope() никогда не завершится, 
            // уйдя в deadlock
            // но deadlock это также совершенно безопасно
            // с точки зрения memory safety. Застрявшая 
            // программа не может испортить память.
            scope.decrement_num_running_threads(unhandled_panic);
        }
    }
}

```

Если заглянуть в async Rust, то можно обнаружить, что проблема в целом идет еще дальше, переходя в проблему cancel safety -- уничтожения *или* забывания объектов `Future` до их завершения:

3. Для async Rust нет **одновременно** корректных, безопасных и не блокирующих реализаций аналогов`std::thread::scope`.
Например, в [async-scoped](https://crates.io/crates/async-scoped) безопасная версия **блокирует** исполнение, ожидая в цикле. 

> *Unfortunately, since the std::mem::forget method is allowed in safe Rust, the purely asynchronous API here is inherently unsafe.*

4. API для tokio io-uring значительно [отличается](https://docs.rs/tokio-uring/latest/tokio_uring/) от обычного: вместо передачи ссылок на буферы, приходится передавать их целиком, отдавая владение среде исполнения. Новый модный молодежный фреймворк  [compio](https://github.com/compio-rs/compio) следует тому же подходу.


------

По всем этим примерам можно заметить общие паттерны, как приходится выкручиваться из этой затруднительной ситуации:
- То передай владение или скопируй
- То выдели дополнительную память


Для примера, с которого мы начали, можно поступить так:

Для начала изменить сам тип `MyCHandle`:

```rust
struct MyCHandle {
    handle: NonNull<c_lib_handle_t>,
    // Нам теперь нужно отслеживать, существует ли AsyncHandleGuard 
    start_token: Weak<()>
}
```

Дальше довольно много изменений потребуется вокруг
`AsyncHadleGuard`. В этой конкретной главе *для простоты* я буду использовать `Box`. С ним есть проблемы [^4] при таком использовании, но сейчас ими можно пренебречь.

```rust

struct AsyncHandleGuard<'a, F> {
    // Придется, например, брать счетчик ссылок
    token: Arc<()>,
    handle: &'a mut MyCHandle,
   
    // Обработчик теперь нужно хранить. 
    // Причем хранить в отдельной аллокации, 
    // а иначе байты из-под забытого AsyncHandleGuard
    // на стэке могут быть перетерты чем-нибудь
    
    // Также AsyncHandleGuard становится немного
    // самореферентным:
    // Мы сохраним ссылку на F внутри поля 
    // handle (внутри c-библиотеки).
    //
    // от F мы ожидаем стабильности адреса в памяти.
    // Нам не нужна стабильность адреса ВСЕЙ структуры
    // AsyncHandlerGuard. Мы можем аннотировать
    // этот Box с помощью Pin. Отмечу, что эта аннотация
    // конкретно в этом случае ничего,
    // кроме сообщения читающему код, не дает:
    // после создания мы не будем трогать это поле из Rust.
    // Всё его заградительное противоошибочное API нам 
    // не нужно.
    callback: Pin<Box<F>>,
}
```

Изменения деструктора тривиальны -- я из опущу. Я вот с коструктором чуть сложнее

```rust

impl<'a, F: FnMut(&[u8]) + Send> AsyncHandleGuard<'a, F> {

    fn new(h: &'a mut MyCHandle, f: F) -> Self {

        if h.start_token.strong_count() > 0 {
            panic!("Attempt to violate safety: AsyncHandleGuard wasn't dropped")
        }

        let mut callback = Box::pin(f);

        let token = Arc::new(());

        h.start_token = Arc::downgrade(&token);

        unsafe {
            start_handle_data(
                h.handle.as_ptr(), Some(Self::handle),
                (callback.as_mut().get_unchecked_mut() as *mut F).cast::<c_void>(),
            );
        }

        // Здесь мы перемещаем Box<F>. 
        // Согласно текущей документации к нему, все
        // ранее произведенные от него *mut F или *const F
        // формально становятся невалидными. И это может быть
        // использовано компилятором против нас.
        //
        // Как делать правильно и почему -- рассмотрим в отдельной главе 
        Self {
            handle: h,
            callback,
            token,
        }
    }
}


```


------

[^1]: Бьярн Страуструп, в своих ответах на призывы Белого дома отказываться от небезопасных языков, очень любит упоминать, что в C++ вообще-то есть resource safety с помощью деструкторов. Прям как в Rust.

[^2]: Unsound публичные библиотеки существуют. И они решают вполне себе прикладные задачи. Иногда по ошибке, иногда умышленно из-за сложности или недостатка времени и ресурсов на тщательное проектирование, в них встречаются подобные проблемы. На практике нужно не бояться предупреждать своих пользователей о найденных проблемах.

[^3]: Ведь утечка памяти это совершенно безопасно. С точки зрения memory safety: если память утекла, то ссылки на нее остаются валидными. Никаких use-after-free.

[^4]: Внутри `Box` сидит `Unique` с noalias семантикой. Компилятор rustc очень агрессивно и активно использует alias свойства типов при оптимизациях. Так что noalias создает дополнительную с большинстве случаев теоретическую, но иногда и практическую головную боль при использовании `Box<T>` как хранилища для `T`, на который му будем ссылаться только лишь через `*mut T` в FFI.